---
layout: default
title: Chapter 06
parent: Designing Data-Intensive Applications
grand_parent: Books
description: "Chapter 06"
permalink: /books/designing-data-intensive-applications/chapter-06
---

## Chapter 06. 파티셔닝
파티셔닝, 샤딩 - 데이터를 파티션으로 쪼개는 것. 데이터셋이 매우 크거나 질의 처리량이 높다면 필요하다.
파티셔닝을 하는 주된 이유는 **확장성** 때문이다. 
각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있고, 노드 추가하면 질의 처리량 늘릴 수 있다. 
이번 장에서는 
- 대용량 데이터셋을 파티셔닝 하는 방법을 살펴보고
- 데이터색인과 파티셔닝이 상호작용 하는 것을 알아본다.
- 클러스터에 노드 추가/삭제 시 재균형화에 대해서 살펴본다
- 데이터베이스가 어떻게 요청을 올바른 파티션에 전달하고 질의를 실행하는지 살펴본다

### 파티셔닝과 복제
보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다. (여러 다른 노드에 저장해서 내결함성 보장 가능)

### 키-값 데이터 파티셔닝
파티셔닝의 목적은 **데이터와 질의 부하를 노드 사이에 고르게 분산**시키는 것이다.
파티셔닝이 고르게 이뤄지지 않은 경우, **Skewed** 되었다고 말하며, 불균형하게 부하가 높은 파티션을 **핫스팟**이라 한다.
핫스팟을 회피하기 위해 레코드를 할당할 노드를 무작위로 선택할 수도 있지만, 더 좋은 방법으로는 key-value 데이터 모델을 사용하는 것이다. 

1. **키 범위** 기준 파티셔닝
각 파티션에 **연속된 범위의 키**를 할당하는 것이다. 키 범위크기가 반드시 동일할 필요는 없다. (데이터가 고르게 분포하지 않을 수 있기 때문)
각 파티션 내에는 **키를 정렬된 순서로 저장**할 수 있다. 그러나 키 범위 기준 파티셔닝은 특정 접근 패턴이 핫스팟을 유발할 수도 있기 때문에 주의해야 한다. 
이 방법에서는 보통 한 파티션이 너무 커지면 키 범위를 두개로 쪼개 동적으로 리밸런싱을 실행한다.
예시 - A / B / CDE .. 이런식으로 값 적은것은 묶어서

1. **키 해시**값 기준 파티셔닝
쏠림과 핫스팟의 위험 때문에 많은 분산 데이터 스토어는 키의 파티션을 정하는데 **해시함수를 사용**한다. 
해시 파티셔닝을 사용할 때는 보통 고정된 개수의 파티션을 미리 만들어 각 노드에 몇 개씩의 파티션을 할당하며 노드가 추가되거나 제거되면 파티션을 통쨰로 노드 사이에서 이동한다.
하지만 이 경우, 범위 파티셔닝의 장점인 '범위 질의를 효율적으로 실행할 수 있는 능력'을 잃어버린다. 
=> 인접했던 키들이 모든 파티션에 흩어져서 순서가 유지되지 않기 때문.
카산드라의 경우, 복합 기본키를 지정하여 키의 첫 부분에만 해싱 적용해 파티션 결정에 사용하고 남은 칼럼은 연쇄된 색인으로 사용 (두가지 기법 섞음)

<img width="376" alt="image" src="https://user-images.githubusercontent.com/39396725/205676543-07654553-f9f2-4e85-9996-12cfbcd8a41c.png">

### 쏠린 작업부하와 핫스팟 완화
키를 해싱해서 파티션을 정하면 핫스팟을 줄이는 데 도움이 된다. 하지만 항상 동일한 키를 읽고 쓰는 극단적인 상황에서는 동일한 파티션으로 모든 요청이 쏠린다. 
현대 데이텉 시스템의 대부분은 쏠린 작업 부하를 자동으로 보정하지 못하므로, 애플리케이션에서 쏠림을 완화해야 한다. 
예시 - 키의 시작이나 끝에 임의의 숫자를 붙인다. -> 이것은 읽거나 쓸때 추가적인 작업이 필요함으로 요청이 몰리는 소수의 키에만 적용해야 한다. 

### 파티셔닝과 보조 색인
키-값 데이터 모델에 의존하는 파티셔닝 방식은 보조색인이 연관되면 상황은 복잡해진다. 
보조색인이란 레코드를 유일하게 식별하는 용도가 아니라 특정 값 기반으로 검색하는 수단 
보조색인은 관계형 데이터베이스의 핵심 요소이며 데이터 모델링에 매우 유용하다. / 솔라나 엘라스틱 서치와 같은 검색 서버에는 존재 이유다. 
보조 색인이 있는 데이터 베이스를 파티셔닝 하는데는 '문서 기반 파티셔닝'과 '용어 기반 파티셔닝'방식이 쓰인다.

#### 문서 기준 보조 색인 파티셔닝 (지역 색인)
각 문서 id 기반으로 파티셔닝, 각 파티션은 자신의 보조색인을 유지하며 그 파티션에 속하는 문서만 탐색한다. (지역 색인)
보조 색인을 기본키와 값이 저장된 파티션에 저장한다. 쓸때는 파티션만 갱신하면 되지만, 보조색인을 읽으려면 모든 파티션에 걸쳐서 모으고 합치는 과정을 진행해야 한다. 
-> 이과정을 스캐터/개더 라고 한다. 
<img width="370" alt="image" src="https://user-images.githubusercontent.com/39396725/205674963-db854aab-1207-4e66-967a-ceac7a35a8a3.png">

#### 용어 파티셔닝 색인 (전역 색인)
찾고자 하는 용어에 따라 색인의 파티션이 결정됨 -> 용어 기준으로 파티셔닝 되었다..
색인된 값을 사용해서 보조 색인을 별도로 파티셔닝 한다. 보조 색인 항복은 기본키의 모든 파티션에 있는 레코드를 포함할 수도 있다. 문서를 쓸 때는 보조 색인 여러개를 갱신해야 하지만 읽기는 단일 파티션에서 실행될 수 있다. (읽기가 효율적, 쓰기가 느리고 복잡) 

<img width="463" alt="image" src="https://user-images.githubusercontent.com/39396725/205675115-6f54b73d-afdf-4986-8ef0-d6f987188d63.png">

### 파티션 재균형화
데이터베이스에 변화가 생겨서, cpu 더 늘리고 싶거나 디스크나 램 추가하고 싶거나, 다른 장비로 역할 넘겨야 하는 경우, 즉 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화 라고 한다. 

재균형화 후에도 아래 요구사항을 만족해야 한다
- 부하가 노드 사이에 균등해야함
- 재균형화 도중에도 db는 읽기요청 받아들어야 함
- 재균형화 빨리 되고, 네트워크 디스크 부하 최소화 하려면 노드들 사이에 데이터가 필요 이상으로 옮겨지면 안된다

#### 재균형화 전략
1. (쓰면 안되는 방법) 해시값에 모드 N 연산 진행
노드 개수가 바귀면 대부분의 키가 노드 사이에 옮겨져야 하므로, 재균형화 비용이 지나치게 커져서 사용하지 않는 방법이다. 

2. 파티션 개수 고정
파티션을 노드 대수보다 크게 만들고, 각 노드에 여러 파티션 할당 -> 노드 추가되면 새 노드는 다시 균일하게 분배될때까지 기존 노드에서 파티션 몇개 뺏어옴
-> 노드에 어떤 파티션이 할당되는지만 변함
보통 이렇게 구축한 경우 처음 구축시 파티션 개수 고정되고 이후에 변하지 않는다.

3. 동적 파티셔닝
파티션을 동적으로 만들어서 파티션 크기가 설저된 값을 넘어서면 파티션을 두개로 쪼개 각각에 원래 파티션의 절반 정도의 데이터가 포함되게 한다.
파티션 개수가 전체 데이터 용량에 맞추어 조정된다는 이점이 있지만, 시작할땐 파티션이 하나라는 단점이 있다.

4. 노드 비례 파티셔닝
파티션 개수가 노드 대수에 비례하게 한다. 즉 노드당 할당되는 파티션 개수를 고정한다 

#### 운영: 자동 재균형화와 수동 재균형화
카우치베이스, 리악, 볼드모트는 자동으로 파티션할당을 제안하지만 관리자가 확정해야함
완전 자동 재균형화는 손이 덜가지만 예측하기 어렵고, 주의깊게 처리하지 않으면 많은 문제가 생길 수 있다. 이런 이유로 사람이 개입하는게 좋을 수 있다.

### 요청라우팅
많은 분산 데이터 시스템은 클러스터 메터데이터를 추적하기 위해 주키퍼 같은 별도의 코디네이션 서비스를 사용한다.
각 노드는 주키퍼에 자신을 등록하고, 주키퍼는 이를 관리한다.
클라이언트및 다른 구성 요소들은 주키퍼의 정보를 구독한다.

### 병렬 질의 실행
지금까지는 단일 키 읽거나 쓰는 간단한 질의만 다뤘지만, 분석용으로 자주 사용되는 대규모 병렬질의의 경우는 훨씬더 복잡한 종류의 질의를 지원한다 (조인, 필터링, 등등)
이는 10장에서 볼 예정 
